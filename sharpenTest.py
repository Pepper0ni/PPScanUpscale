from __future__ import print_function
import cv2 as cv
import argparse
import numpy as np
import math
from skimage.filters import unsharp_mask
from skimage.util import img_as_ubyte

ksize = 3
sigma = 141
iter = 1

window_detection_name = 'Object Detection'

def ksizeTrackbar(val):
    global ksize
    ksize = val

def sigmaTrackbar(val):
    global sigma
    sigma = val

def iterTrackbar(val):
    global iter
    iter = val

def trimImage(img, fromTop, newBot, fromLeft, newRight):
    return img[fromTop:newBot, fromLeft:newRight]

def sharpen(hsvSrc, ksize, sigma, iter):
    h, s, v = cv.split(hsvSrc)
    #gaussKern = cv.getGaussianKernel(ksize, -sigma)
    #baseKern = np.zeros([ksize, ksize], dtype=np.uint8)
    #baseKern[ksize-math.ceil(ksize/2), ksize-math.ceil(ksize/2)] = 1
    #kernel = baseKern + (baseKern - gaussKern/ksize)
    #print(kernel)
    #print(np.sum(kernel))
    #kernel = np.array([[-sigma, -sigma, -sigma], [-sigma, 1+(8*sigma), -sigma], [-sigma, -sigma, -sigma]])
    for _ in range(iter):
        v = img_as_ubyte(unsharp_mask(v, ksize, sigma))
        #v = cv.filter2D(v, -1, kernel)

    return cv.merge([h, s, v])


parser = argparse.ArgumentParser(description='Code for Thresholding Operations using inRange tutorial.')
parser.add_argument("-i", "--Input", help="Set Input")

args = parser.parse_args()
image = cv.imread(cv.samples.findFile(args.Input))
size = (round(image.shape[1]/2), round(image.shape[0]/2))
#image = cv.resize(image, size, cv.INTER_AREA)
hsvImage = cv.cvtColor(image, cv.COLOR_BGR2HSV)

cv.namedWindow(window_detection_name, cv.WINDOW_NORMAL)
cv.createTrackbar("ksize", window_detection_name, ksize, 10, ksizeTrackbar)
cv.createTrackbar("sigma", window_detection_name, sigma, 400, sigmaTrackbar)
cv.createTrackbar("iter", window_detection_name, iter, 20, iterTrackbar)

while True:
    sharp = sharpen(hsvImage, ksize, sigma/500, iter)
    cv.imshow(window_detection_name, cv.cvtColor(sharp, cv.COLOR_HSV2BGR))
    key = cv.waitKey(30)
    if key == ord('q') or key == 27:
        break